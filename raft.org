* Consensus Algorithm

** State
   
| persistent (all) | volatile (all) | volatile (only leader) |
|------------------+----------------+------------------------|
| currentTerm      | commitIndex    | nextIndex[]            |
| votedFor         | lastAppend     | matchIndex[]           |
| log[]            |                |                        |

persistent means that the variables are updated on the local stable storage
before responding to RPCs

- =currentTerm=: latest term the server has seen
- =votedFor=: candidate id that received the vote in the last term
- =log[1...L]=: log entries, each entry consists of term number and the command

- =commitIndex=: index of highest entry known to be committed (initialized to 0,
  increases monotonically)
- =lastApplied=: index of highest entry applied to the state machine
  (initialized to 0, increases monotonically)

- =nextIndex[P0...PN]=: index of the next log entry to send (initialized to
  leader's last log index + 1)
- =matchIndex[P0...PN]=: index of the highest log entry known to be replicated
  (initialized to 0, increases monotonically)
  
** Comparison functions

#+BEGIN_SRC haskell
-- true if log entry e2 is at least as recent as e1
le (e1@(t1,i1)) (e2@(t2,i2)) =
  t1 < t2 ||                  -- e2 belongs to a newer term, or
  (t1 == t2 && i1 <= i2)      -- they belong to the same term and e2 comes after

-- check if entry is at least as recent as the last entry in the log
isRecent logs (entry@(term,index)) =
  let lli       = length logs
      (llt,cmd) = last logs
  in le (llt, lli) entry
#+END_SRC

** Follower

#+BEGIN_SRC haskell
case msg of
  RequestVote(term, pid, lastLogIndex, lastLogTerm) ->
    if   term < currentTerm
    then
      -- received message from a previous leader
      send pid RequestVoteResponse(currentTerm, False)
    else do
      -- update current term
      set currentTerm term
      if   votedFor == None && isRecent log (lastLogTerm, lastLogIndex)
        then do
          -- vote only once
          set votedFor pid
          -- respond with success
          send pid RequestVoteResponse(currentTerm, True)
        else
          -- we have already voted for someone else, or
          -- candidate's last log entry is not as recent as ours
          send pid RequestVoteResponse(currentTerm, False)

  AppendEntries(term, pid, prevLogIndex, prevLogTerm, entries, lastCommit) ->
    if   term < currentTerm
    then
      -- received message from a previous leader
      send pid AppendEntriesResponse(currentTerm, False)
    else do
      -- update current term
      set currentTerm term
      -- find the index right before where the entries should go
      let (t, cmd) = log !! prevLogIndex
      if t /= prevLogTerm
        then
          -- local previous log entry does not match leader's
          send pid AppendEntriesResponse(currentTerm, False)
        else do
          -- use entries to update and/or extend the local log
          forM [prevLogIndex + 1 ... length entries] $ \i ->
            set log i (entries !! i)
          -- check if leader has new entries committed
          when (lastCommit > commitIndex) $
            set commitIndex (min localCommit (prevLogIndex + length entries))
          -- respond with success
          send pid AppendEntriesResponse(currentTerm, True)
#+END_SRC


# * Consensus Algorithm

# ** State

# #+BEGIN_SRC haskell
# data Pid = Int

# data Entry = Entry { cmdTerm :: Int    -- term when entry is received
#                    , command :: String -- command for the state machine
#                    }

# data ServerType = Follower | Candidate | Leader

# data State = State { -- -----------------------------------------------------------
#                      -- Persistent state on all servers
#                      -- -----------------------------------------------------------
#                        currentTerm :: Int       -- latest term server has seen
#                      , votedFor    :: Maybe Pid -- pid of the candidate voted for
#                                                 -- in current term
#                      , log         :: [Entry]   -- log entries
#                      -- -----------------------------------------------------------
#                      -- Volatile state on all servers
#                      -- -----------------------------------------------------------
#                      , commitIndex :: Int -- index of highest log entry known committed
#                      , lastApplied :: Int -- index of highest log entry applied to the 
#                                           -- state machine
#                      -- -----------------------------------------------------------
#                      -- Volatile state on leaders
#                      -- -----------------------------------------------------------
#                      , nextIndex  :: [Int] -- for each server, index of the next
#                                            -- log entry to send to that server
#                      , matchIndex :: [Int] -- for each server, index of highest log
#                                            -- entry known to be replicated on server
#                      }  

# #+END_SRC
  
# ** RPC Messages

# #+BEGIN_SRC haskell
# data Message =
#     RequestVote { term         :: Int -- candidate's term
#                 , candidateId  :: Pid -- candidate requesting vote
#                 , lastLogIndex :: Int -- index of candidate's last log entry
#                 , lastLogTerm  :: Int -- term of candidate's last log entry
#                 }
  
#   | RequestVoteResp { term        :: Int  -- for candidate to update itself
#                     , voteGranted :: Bool -- true means candidate received vote
#                     }
  
#   | AppendEntries { term         :: Int     -- leader's term
#                   , leaderId     :: Pid     -- so follower can redirect clients
#                   , prevLogIndex :: Int     -- index of log entry immediately preceding new ones
#                   , prevLogTerm  :: Int     -- term of prevLogIndex entry
#                   , entries      :: [Entry] -- log entries to store, empty for heartbeat
#                   , leaderCommit :: Int     -- leader's commit index
#                   }
  
#   | AppendEntriesResp { term    :: Int -- for leader to update itself
#                       , success :: Pid -- true if follower contained entry matching
#                                        -- prevLogIndex and prevLogTerm
#                       }

# #+END_SRC

# ** Leader Election

# #+BEGIN_SRC haskell
# n       = 5
# -- every node on the system
# servers :: [Pid]
# servers =  [1..n]

# -- candidate's event loop
# candidate :: State -> Process ()
# candidate s@(State{..}) = do
#   self <- getSelfPid
#   let term' = term + 1
#       msg   = RequestVote { term         = term'
#                           , candidateId  = self
#                           , lastLogIndex = length log
#                           , lastLogTerm  = cmdTerm (last log)
#                           }
#   -- request vote from everyone
#   forM servers (\p -> send p msg)

#   let s' = s { term      = term'
#              , votedFor  = Just self
#              }
#   waitForVotes s' 1

# waitForVotes :: State -> Int -> Process () 
# waitForVotes s@(State{..}) c =
#   if   2 * c > n
#   then leader s                 -- become the leader
#   else do msg <- recv
#           case msg of
#             RequestVoteResp(term',vote) ->
#               if   vote
#               then waitForVotes s (c+1)
#               else if term' > term
#                    then follower (s { term = term' }) -- become a follower
#                    else waitForVotes s c -- loop
#             Timeout ->
#               candidate s       -- restart a new election
#             AppendEntries(term',pid,prevLI,prevLT,commitI) ->
#               if   term' >= term
#               then follower (s { term = term' }) -- become a follower
#               else waitForVotes s c -- loop

# -- follower's event loop              
# follower :: State -> Process ()
# follower s@(State{..}) = do
#   msg <- recv
#   case msg of
#     RequestVote(term',pid,lli,llt) ->
#       do let my_lli = length log
#              my_llt = cmdTerm (last log)
#          when (term' > term &&                                  -- is it a new term ?
#                (votedFor == Just pid || votedFor == Nothing) && -- have I voted before ?
#                (llt,lli) >= (my_llt, my_lli)) $                  -- is candidate up to date ?
#            send pid (RequestVoteResp term True)
#     ...
# #+END_SRC


