* Properties
** State
   
| persistent (all) | volatile (all) | volatile (only leader) |
|------------------+----------------+------------------------|
| currentTerm      | commitIndex    | nextIndex[]            |
| votedFor         | lastAppend     | matchIndex[]           |
| log[]            |                |                        |

persistent means that the variables are updated on the local stable storage
before responding to RPCs

- =currentTerm=: latest term the server has seen
- =votedFor=: candidate id that received the vote in the last term
- =log[1...L]=: log entries, each entry consists of term number and the command

- =commitIndex=: index of highest entry known to be committed (initialized to 0,
  increases monotonically)
- =lastApplied=: index of highest entry applied to the state machine
  (initialized to 0, increases monotonically)

- =nextIndex[P0...PN]=: index of the next log entry to send (initialized to
  leader's last log index + 1)
- =matchIndex[P0...PN]=: index of the highest log entry known to be replicated
  (initialized to 0, increases monotonically)
  
** Comparison functions

#+BEGIN_SRC haskell
-- true if log entry e2 is at least as recent as e1
le (e1@(t1,i1)) (e2@(t2,i2)) =
  t1 < t2 ||                  -- e2 belongs to a newer term, or
  (t1 == t2 && i1 <= i2)      -- they belong to the same term and e2 comes after

-- check if entry is at least as recent as the last entry in the log
isRecent logs (entry@(term,index)) =
  let lli       = length logs
      (llt,cmd) = last logs
  in le (llt, lli) entry
#+END_SRC

* Types of Processes

Follower and candidate processes are of the following form:

#+BEGIN_SRC
while true:
  msg <- recv
  case msg of
    ...
#+END_SRC

Leader is not because it sends and empty =AppendEntries= message to everyone
when it's elected, and doing this in the candidate process would create a race
condition.

** Follower

#+BEGIN_SRC haskell
case msg of
  RequestVote(term, pid, lastLogIndex, lastLogTerm) ->
    if term < currentTerm then
      -- received message from a previous leader
      send pid RequestVoteResponse(currentTerm, False)
    else do
      -- update current term
      set currentTerm term
      if   votedFor == None && isRecent log (lastLogTerm, lastLogIndex)
        then do
          -- vote only once
          set votedFor (Just pid)
          -- respond with success
          send pid RequestVoteResponse(currentTerm, True)
          -- reset the timer since we voted for a candidate (a possible future leader)
          reset Timer
        else
          -- we have already voted for someone else, or
          -- candidate's last log entry is not as recent as ours
          send pid RequestVoteResponse(currentTerm, False)

  AppendEntries(term, pid, prevLogIndex, prevLogTerm, entries, lastCommit) ->
    if term < currentTerm then
      -- received message from a previous leader
      send pid AppendEntriesResponse(currentTerm, False)
    else do
      reset Timer           -- since we heard from the current or a newer leader
      -- update current term
      set currentTerm term
      set votedFor    None
      -- find the index right before where the entries should go
      let (t, cmd) = log !! prevLogIndex
      if t /= prevLogTerm then
          -- local previous log entry does not match leader's
          send pid AppendEntriesResponse(currentTerm, False)
        else do
          -- use entries to update and/or extend the local log
          forM [prevLogIndex + 1 ... length entries] $ \i ->
            set log i (entries !! i)
          -- check if leader has new entries committed
          when (lastCommit > commitIndex) $
            set commitIndex (min localCommit (prevLogIndex + length entries))
          -- respond with success
          send pid AppendEntriesResponse(currentTerm, True)
#+END_SRC

** Candidate

We need to keep track of 2 extra variables here:
1. =noOfGrants= to keep track of grants for its candidacy
2. =isLeader= is set when =noOfGrants= reaches a majority


#+BEGIN_SRC haskell
case msg of
  -- if the candidate doesn't hear back from a majority during its election
  -- period or doesn't get a heart beat message from the leader for a while, it
  -- starts another election
  Timer -> do
    -- update the state for a new election
    set currentTerm (currentTerm + 1)
    set votedFor    (Just self)
    set isLeader    False
    set noOfGrants  1
    -- request vote from everyone
    forM every_server $ \p ->
      let lli       = length log
          (llt,cmd) = last log
      in send p RequestVote(currentTerm, self, lli, llt)
         
  RequestVoteReply(term, voteGranted) ->
    if term > currentTerm then do
      -- update the term and be a follower
      set votedFor    None
      set currentTerm term
    else if voteGranted then do
      -- increment vote count
      set noOfGrants (noOfGrants + 1)
      when (2 * noOfGrants > no_of_procs) $
        -- become the leader
        set isLeader True
    else
      -- keep waiting for remaining responses
      return ()
#+END_SRC

** Leader

- Upon election: send initial empty =AppendEntries= RPCs (heartbeat) to each
  server; repeat during idle periods to prevent election timeouts.

- If command received from client: append entry to local log, respond after
  entry applied to state machine.

- If =last log index= >= =nextIndex= for a follower: send =AppendEntries= RPC
  with log entries starting at =nextIndex=

  - If successful: update =nextIndex= and =matchIndex= for follower

  - If =AppendEntries= fails because of log inconsistency: decrement =nextIndex=
    and retry

- If there exists an N such that N > =commitIndex=, a majority of
  =matchIndex[i]= >= N, and =log[N].term= == =currentTerm=: set =commitIndex= to
  N.

#+BEGIN_SRC haskell
asdf                            -- remove this

synchronizeWithFollowers =
  -- back and forth between the followers and the leader
  -- it forces the followers to have the same log sequence as the leader
  undefined

leader = do
  set commitIndex 0
  set lastApplied 0
  
  -- send an empty AppendEntries msg to announce leadership
  forM every_server $ \p ->
    let lli       = length log
        (llt,cmd) = last log
    in send p AppendEntries(currentTerm, self, lli, llt, [], commitIndex)
  -- sync with followers
  synchronizeWithFollowers
  leaderLoop

leaderLoop = do
  ClientMsg{..} <- recv
  forM every_server $ \p ->
    let lli       = length log
        (llt,cmd) = last log
    in send p AppendEntries(currentTerm, self, lli, llt, [], commitIndex)
  -- TODO: counting of received msgs
  loop
#+END_SRC

